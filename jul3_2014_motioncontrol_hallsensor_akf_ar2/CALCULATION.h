//After varification, self-made Matrix calculation is right

#ifndef CALCULATION_H
#define CALCULATION_H

#include <windows.h>
#include <fstream>
#include <vector>
#include "math.h"

using namespace std;


#define R_norm            550.0               //um (R_norm) (Normalized Workspace Center)
//#define SplRate           1606                //Hz (high freq.in FPGA, 1606 is the hard limit in the current FPGA)
#define SplRate           1612                //Hz, 100,000/1612 = 62 (1612 is selected since 100,000 can be divided by 1612)
#define SplIntv           (1.0/SplRate)       //sec
#define SimuRate          100000              //Simulation frequency (HAS TO BE 100,000 WHEN HALL SENSOR IS USED)
////#define SimuRate          1612                //Simulation frequency
#define SimuIntv          (1.0/SimuRate)      //Simulation Interval

#define PI           	  (4.0*atan(1.0))
#define m2um         	  (1e6)
#define um2m         	  (1e-6)
#define nm2um        	  (1e-3)
#define pN2N         	  (1e-12)
#define N2pN         	  (1e12)
//#define mV2V              (1e-3)


#define CalcAngStep       (2*PI/60)
#define X                 0
#define Y                 1
#define Z                 2
//#define DELAY_STEP        4  //
#define DELAY_STEP_Meas   2   //Control Delay in the loop
#define DELAY_STEP_Esti   2   //DELAY_STEP_Esti should = DELAY_STEP_Meas

#define THEO              0 //Theoretical Inverse Model
#define REAL              1 //Real Inverse Model, the KI matrix is from experiment

#define ADAPT_KF          0 //Adaptive Kalman-filter
#define CONST_KF          1 //Constant covariance matrix

#define CIRC_TRK          0 //Circular Tracking
#define RAMP_TRK          1 //Ramp Tracking

//#define WithHALL          0
//#define NoHALL            1

#define WTR               0  //in Water
#define GLY               1  //in Glycerol


enum //Controller
{ 	
	P_ctrl,
	PID_ctrl,
	PID_DS_ctrl,
	SM_ctrl,
	SupTwistSM_ctrl,
	DiscrSM_ctrl,
};
enum
{
	DOWN,
	UP,
};

class CALCULATION
{
   
public:

	double *DampWtr_X_Oa_RD,
		   *DampWtr_Y_Oa_RD,
		   *DampWtr_Z_Oa_RD,  //data (in Water) is generated by MATLAB (Either Water or Glycerol is chosen)

		   *DampGly_X_Oa_RD,
		   *DampGly_Y_Oa_RD,
		   *DampGly_Z_Oa_RD;  //data (in Glycerol) is generated by MATLAB

	int    Simu_StepNum;

   //#####################################
   //****** Force model parameters: ******
   //#####################################
   double KItheo[6][6],    KItheo_T[6][6],
	      KIreal[6][6],    KIreal_T[6][6],     //Read from file
		  InvKIreal[6][6], InvKIreal_T[6][6],  //Read from file
		  TipCoeff_KIreal,                     //the lower pole has different shape
		  id_m2a[3][3],    id_a2m[3][3],       //coordinate transform: m2a: measurement coordinate to actuation coordinate and vice versa
          FGain_x, 
		  FGain_y, 
		  FGain_z; //Force gain in 3 directions (in pN) 
   //##########################################
   //****** (end) Force model parameters ******
   //##########################################



   //##############################################
   //****** Interm. value & Lx, Ly, Lz CALC: ******
   //##############################################
   double Bias_umOa_P1toP6[18]; //Biases of 6 poles, each pole has bias in x,y,z directions, so 18-dimensional vector; umOa: um in Actuation coordination; Om is Measurement coordinate
   double Dx1_x, Dx2_x, Dx3_x, Dx4_x, Dx5_x, Dx6_x, //Dx1: delta(bias) of pole 1 in x direction; Dx1_x = Dx1 - x, wherein x is the bead position in x direction
	      Dy1_y, Dy2_y, Dy3_y, Dy4_y, Dy5_y, Dy6_y,
		  Dz1_z, Dz2_z, Dz3_z, Dz4_z, Dz5_z, Dz6_z, //******//The Bias is in Oa, normalized position
		  Dx1_xPlus1, x_Dx2Plus1, //Dx1_xPlus1 = Dx1 - x + 1
		  Dy3_yPlus1, y_Dy4Plus1,
		  Dz5_zPlus1, z_Dz6Plus1,
		  Sq_r1, Sq_r2, Sq_r3, Sq_r4, Sq_r5, Sq_r6, //Sq_r1: square of r1, wherein r1 is from pole 1 to the bead position
          Lx[6][6], Ly[6][6], Lz[6][6],             //Lx,Ly and Lz are discribed in the paper
	      Nx_KItheo[6][6], Ny_KItheo[6][6], Nz_KItheo[6][6], //Nx = KI' * Lx * KI, _KItheo means using theoretical KI matrix
	      Nx_KIreal[6][6], Ny_KIreal[6][6], Nz_KIreal[6][6],
		  x, y, z;
   //###################################################
   //****** (end) Interm. value & Lx, Ly, Lz CALC ******
   //###################################################



   //###############################################
   //****** Optimum Inverse Model for KItheo: ******
   //###############################################
   int    OptInvMdl_RowNum, 
	      OptInvMdl_ColNum, //1891 x 10
          ind1, ind2, ind3, ind4,
	      IntThe, IntPhi;
   double **InvMdl_Coeff_I1, 
	      **InvMdl_Coeff_I2,
		  **InvMdl_Coeff_I3,
		  **InvMdl_Coeff_I4,
		  **InvMdl_Coeff_I5,
		  **InvMdl_Coeff_I6,
          FracThe,  FracPhi,
          AngleThe, AnglePhi, //Nominal Orientation
          TheOct1,  PhiOct1,  //Octant1 CounterPart
		  PosCoeff[10],
		  Fdsir_Mag_pN,
          I1toI6_KItheo[6],    I1toI6_KIreal[6],  //current
          FNor_Curr_KItheo[3], FNor_Curr_KIreal[3];   //Normalized force
   double I1_ind1, I1_ind2, I1_ind3, I1_ind4,
	      I2_ind1, I2_ind2, I2_ind3, I2_ind4,
	      I3_ind1, I3_ind2, I3_ind3, I3_ind4,
	      I4_ind1, I4_ind2, I4_ind3, I4_ind4,
	      I5_ind1, I5_ind2, I5_ind3, I5_ind4,
	      I6_ind1, I6_ind2, I6_ind3, I6_ind4,

          I1_mid13, I1_mid24, I1_interp,
		  I2_mid13, I2_mid24, I2_interp,
		  I3_mid13, I3_mid24, I3_interp,
		  I4_mid13, I4_mid24, I4_interp,
		  I5_mid13, I5_mid24, I5_interp,
		  I6_mid13, I6_mid24, I6_interp;
   //####################################################
   //****** (end) Optimum Inverse Model for KItheo ******
   //####################################################



   //################################
   //****** For control schem: ******
   //################################
   int    PosCtrl_Counter;
   double Pgain[3],
	      Igain[3],
		  Dgain[3], //PID gain
          
		  SupTwist_M, 
		  SupTwist_a, //SupTwisting
	      
		  SM_Mag; //Sliding Mode
   double ERRpos_umOm[3], 
	      ERRpos1_umOm[3], 
		  ERRpos2_umOm[3],
		  //
	      Fd_pNOm[3], 
		  Fd1_pNOm[3], 
		  Fd2_pNOm[3],
	      
		  Fd_pNOa[3], 
		  Fd1_pNOa[3], 
		  Fd2_pNOa[3], //from controller
		  //
		  Coeff_ErrPos_pNOm[3],
		  Coeff_ErrPos1_pNOm[3],
		  Coeff_ErrPos2_pNOm[3], //PID control coeff
		  
		  Vsuptwist_pNOm[3],
		  V1suptwist_pNOm[3]; //Super Twisting Control
   //#####################################
   //****** (end) For control schem ******
   //#####################################



   //#############################
   //****** Trk simulation: ******
   //#############################
   int    LEN_Simu_Meas, //TRK can be Positioning / Tracking
	      Simu_Real_LEN; //Pos_Meas has delay compared with Pos_Real

   double *Simu_TX_umOm, *Simu_TY_umOm, *Simu_TZ_umOm,  //Target_Om
		  *Simu_RX_umOm, *Simu_RY_umOm, *Simu_RZ_umOm,  //Real
	      *Simu_MX_umOm, *Simu_MY_umOm, *Simu_MZ_umOm,  //Meas (lag w.r.t. Real)
		  
		  *Simu_TX_umOa, *Simu_TY_umOa, *Simu_TZ_umOa,  //Actuation coordinate
		  *Simu_RX_umOa, *Simu_RY_umOa, *Simu_RZ_umOa,
	      *Simu_MX_umOa, *Simu_MY_umOa, *Simu_MZ_umOa,

		  *TRK_Vx_Om, *TRK_Vy_Om, *TRK_Vz_Om,
		  *Trk_Vx_Oa, *Trk_Vy_Oa, *Trk_Vz_Oa,
		  
		  *Simu_I1, *Simu_I2, *Simu_I3, *Simu_I4, *Simu_I5, *Simu_I6,
		  
		  *Simu_FdX_pNOm, *Simu_FdY_pNOm, *Simu_FdZ_pNOm, 
		  *Simu_FdX_pNOa, *Simu_FdY_pNOa, *Simu_FdZ_pNOa, 
		  *Simu_FdX_norOm,*Simu_FdY_norOm,*Simu_FdZ_norOm,
		  *Simu_FdX_norOa,*Simu_FdY_norOa,*Simu_FdZ_norOa,
		  *Simu_FXcalc_pNOa, *Simu_FYcalc_pNOa, *Simu_FZcalc_pNOa; //for data checking

   //**** Thermal Motion and Measurement Noise are from MATLAB file: ****
   int    LEN_ThmMotion,
	      LEN_ThmForce,
	      LEN_MeasNoise;
   double *ThmMotion_X_RD,     *ThmMotion_Y_RD,     *ThmMotion_Z_RD,
	      *ThmForce_X_NOa_RD,  *ThmForce_Y_NOa_RD,  *ThmForce_Z_NOa_RD,
          *MeasNoise_X_mOm_RD, *MeasNoise_Y_mOm_RD, *MeasNoise_Z_mOm_RD;
   double Fx_pNOa_k,  Fy_pNOa_k,   Fz_pNOa_k,
	      Px_umOa_k1, Py_umOa_k1,  Pz_umOa_k1,
		  Px_umOa_k,  Py_umOa_k,   Pz_umOa_k;

   double Trap_Target_umOm[3];

   int    sign(double e);
   //##################################
   //****** (end) Trk simulation ******
   //##################################


   //#########################
   //#########################
   //****** Estimation: ******
   //#########################
   //#########################
   double P_XYZ_umOa_forEsti[3], //with Delay information in that
	      In_P1toP6_forEsti[6];  //with Delay information in that

   double kB,     //Boltzmann
          T,      //Abs Temp
          lambda, //forgetting factor
          //
		  *F_Ext_x_pN_Apply, //(This is the real external force)
		  *F_Ext_y_pN_Apply, //(This is the real external force)
		  *F_Ext_z_pN_Apply, //applied force in pN (This is the real external force)
		  //
		  *Damp_x_ESTI,
		  *Damp_y_ESTI,
		  *Damp_z_ESTI,
		  *pN_O_Damp_x_ESTI, 
		  *pN_O_Damp_y_ESTI, 
		  *pN_O_Damp_z_ESTI, 
		  //
		  Vari_thm_x,
		  Vari_thm_y,
		  Vari_thm_z,
		  *Vari_Tot_x_ESTI,  
		  *Vari_Tot_y_ESTI,  
		  *Vari_Tot_z_ESTI, //actually, this is Vari(Thm) + Vari(Motion)
		  *Vari_Meas_x_ESTI, 
		  *Vari_Meas_y_ESTI, 
		  *Vari_Meas_z_ESTI,
		  //
		  *M_Ext_x_ESTI, 
		  *M_Ext_y_ESTI, 
		  *M_Ext_z_ESTI, //total motion (due to external force)
	      *F_Ext_x_ESTI,    
		  *F_Ext_y_ESTI,    
		  *F_Ext_z_ESTI, //total force (external force)
		  //
		  beta, //******//for AR2 model
		  PHI[3][3], PHI_T[3][3], 
		  STATE_k_k_x    [3], STATE_k_k_y    [3], STATE_k_k_z    [3],
		  STATE_k_km1_x  [3], STATE_k_km1_y  [3], STATE_k_km1_z  [3],
		  STATE_km1_km1_x[3], STATE_km1_km1_y[3], STATE_km1_km1_z[3],
		  //
		  Qw1_x, 
		  Qw2_x, 
		  Qw_x[3][3], //w mean process noise

		  Qw1_y, 
		  Qw2_y, 
		  Qw_y[3][3],

		  Qw1_z, 
		  Qw2_z, 
		  Qw_z[3][3], //Initial Guess
		  //
		  *OBSRV_x, *OBSRV_y, *OBSRV_z,
		  *INNOV_x, *INNOV_y, *INNOV_z,
		  //
		  *Fx_pNOa_Curr, *Fy_pNOa_Curr, *Fz_pNOa_Curr, //in pN, *pN2N to get SI unit
		  //
		  Hx_k[3], Hy_k[3], Hz_k[3], //Observation matrix
		  //
		  P_k_k_x    [3][3], P_k_k_y    [3][3], P_k_k_z    [3][3], 
		  P_k_km1_x  [3][3], P_k_km1_y  [3][3], P_k_km1_z  [3][3],
		  P_km1_km1_x[3][3], P_km1_km1_y[3][3], P_km1_km1_z[3][3],
		  //
		  Sx_k, Sy_k, Sz_k, //Real Value of Innov. Cov.
		  //
		  Kx_k[3], Ky_k[3], Kz_k[3],
		  //
		  EYE[3][3],

		  PHI_M_STATE_km1_km1_x[3],
		  PHI_M_STATE_km1_km1_y[3],
		  PHI_M_STATE_km1_km1_z[3],

		  PHI_M_P_km1_km1_M_PHIT_x[3][3],
		  PHI_M_P_km1_km1_M_PHIT_y[3][3],
		  PHI_M_P_km1_km1_M_PHIT_z[3][3];

   int    Index,
		  ThmF_Counter;

   void   Estimation_Init(int LIQUID_TYPE);

   void   Get_STATE_k_km1();     //Time Update
   void   Get_EstiCov_P_k_km1(); //Time Update
   //
   void   Get_InnovCov();      //Meas. Update
   void   Get_KalmanGain_K();  //Meas. Update
   void   Get_STATE_k();       //Meas. Update
   void   Get_EstiCov_P_k_k(); //Meas. Update
   //
   void   Esti_Update_Parameter(); //Contains all the above functions

   //##############################
   //##############################
   //****** (end) Estimation ******
   //##############################
   //##############################



   //###############################
   //###### member functions: ######
   //###############################
   CALCULATION();  //constructor
   ~CALCULATION();

   void   Simu_Finalize(); //main purpose: delete pointers

   void   Read_ThmMotion_XYZ(char* fname_ThmMotionXYZ);  //The White Gaussian Noise is generated by MATLAB
   void   Read_ThmForce_XYZ (char* fname_ThmForceXYZ);   //The White Gaussian Noise is generated by MATLAB
   void   Read_MeasNoise_XYZ(char* fname_MeasNoiseXYZ);  //The White Gaussian Noise is generated by MATLAB

   void   Positioning_Simu_Init (int LEN_Spl); //initailization
   void   Positioning_Simu      (int THEO_or_REAL); //position control
   void   Positioning_Simu_WithEsti (int THEO_or_REAL, int ADAPT_or_CONST_KF);
   //
   void   CircTracking_Init (double CirD_um, double CirSpd_ums, int CirNum);
   void   RampTracking_Init (double RangeXY_um, double RangeZ_um, int UP_or_DOWN, double RampSpd_ums, double RampAngle_deg);
   void   Tracking_Simu (int THEO_or_REAL); //this will work for CircTrk, RampTrk, ect.
   void   Tracking_Simu_WithEsti (int THEO_or_REAL, int ADAPT_or_CONST_KF);
   //

   void   Calc_Pre_L(double Pos_umOa[3]); //taking pos(um) and obtain all intermediate value(For CALC Lx,y,z)
   void   Calc_Lx();  //use NorPos[3] 
   void   Calc_Ly();  //use NorPos[3] 
   void   Calc_Lz();  //use NorPos[3] 
   void   Calc_Nxyz_KItheo (double Pos_umOa[3]);
   void   Calc_Nxyz_KIreal (double Pos_umOa[3]);
   void   Calc_Lxyz        (double Pos_umOa[3]);

   void   Calc_FNor_FromSixCurr_KItheo (double Pos_um[3], double Inor_P1toP6[6]);
   void   Calc_FNor_FromSixCurr_KIreal (double Pos_um[3], double Inor_P1toP6[6]);

   void   OptInvMdl_Curr_FromLS_KItheo (double Fd_pN[3],double Pos_um[3]);
   void   OptInvMdl_Curr_FromLS_KIreal (double Fd_pN[3],double Pos_um[3]);

   void   Calc_Ctrl_Effort_Force(int MODE);
   void   Calc_Ctrl_Coeff_Force ();
   void   Set_PIDgain (double Px, double Py, double Pz, double Ix, double Iy, double Iz, double Dx, double Dy, double Dz);//no D

   void   Calc_NextBeadPos(double PosBef_umOa[3], double PosAft_umOa[3], int THEO_or_REAL);  //simulation calculation, pos in um
   
   double CalcCurrNorm  (double I1toI6[6]);
   double CalcForceNorm (double Fd_pN[3]);
   double MaxAbs_I1toI6 (double I1toI6[6] );

   void   CoordTrans_Vect_m2a(double Vect_m[3], double Vect_a[3]);
   void   CoordTrans_Vect_a2m(double Vect_a[3], double Vect_m[3]);
   void   CoordTrans_Elem_m2a(double Xm, double Ym, double Zm, double *Xa, double *Ya, double *Za); //Need & when refer
   void   CoordTrans_Elem_a2m(double Xa, double Ya, double Za, double *Xm, double *Ym, double *Zm); //Need & when refer

   void   Set_CircTrk_Dia_Spd(double CirD_um, double CirSpd_ums, int CirNum); //Traj. Plan diameter speed
   void   Set_RampTrk_Dia_Spd(double RangeXY_um, double RangeZ_um, int UP_or_DOWN, double RampSpd_ums, double RampAngle_deg); //Traj. Plan
   //###############################
   //###### member functions: ######
   //###############################



   //##################################
   //###### Matrix manipulation: ######
   //##################################
   void   CalcMat_6x6_6x6_6x6  (double Matrix1[][6],double Matrix2[][6],double Matrix3[][6],double result[][6]);
   void   CalcMat_6x6_6x1      (double Mat1[6][6], double Mat2[6], double Result[6]);
   double CalcMat_1x6_6x6_6x1  (double before[6],double Mid[6][6],double after[6]);
   void   CalcInverseMat_3x3   (double before[][3],double after[][3]);
   void   CalcMat_1x3_3x3      (double Mat_3x3[3][3], double result[3]);
   void   CalcMat_3x3_3x1      (double Mat_3x3[3][3], double Mat_3x1[3], double result[3]);
   double CalcMat_1x3_3x1      (double Mat_1x3[3],    double Mat_3x1[3]);
   double CalcMat_1x3_3x3_3x1  (double Mat1_13[3],    double Mat2_33[3][3], double Mat3_31[3]);
   void   CalcMat_3x3_3x3      (double Mat1_33[3][3], double Mat2_33[3][3], double Rst_33[3][3]);
   void   CalcMat_3x3_3x3_3x3  (double Mat1_33[3][3], double Mat2_33[3][3], double Mat3_33[3][3], double Rst_33[3][3]);

   void   CalcMatSum_3x3  (double Mat1_33[3][3], double Mat2_33[3][3], double Rst_33[3][3]);
   void   CalcVectDev_3x1 (double Vect1_31[3],   double devide);
   //#######################################
   //###### (end) Matrix manipulation ######
   //#######################################


   //##########################
   //###### write files: ######
   //##########################
   void   Write_SimuRst_Target_Meas_Real_Curr_Force ( char* fname);
   void   Write_EstiRst_xyz (char *fnamex, char *fnamey, char *fnamez);
   //###############################
   //###### write files (end) ######
   //###############################


   //checking if every parameter is right:
   void OutputParameter();


};

#endif